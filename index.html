<!DOCTYPE html>
<html lang="cs">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>jsPsych: IGA 2025 Dotazn√≠k</title>
  <!-- jsPsych v7 -->
  <script src="https://unpkg.com/jspsych@7.3.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response"></script>
  <link href="https://unpkg.com/jspsych/css/jspsych.css" rel="stylesheet" />
  <style>
    body { height: 100%; margin: 0; }
    .wrap { max-width: 840px; margin: 24px auto; padding: 0 16px; }
    .prompt { margin-bottom: 12px; font-size: 18px; line-height: 1.4; }
    #graphbox { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
    svg { width: 100%; height: 420px; touch-action: none; }
    .node { cursor: grab; }
    .node:active { cursor: grabbing; }
    .node circle { fill: #000000; stroke: #000000; stroke-width: 2px; }
    .edge { stroke: #111; stroke-width: 3px; }
    .ui { display: flex; gap: 8px; align-items: center; margin-top: 10px; }
    .note { color: #555; font-size: 14px; }
    svg text {
      user-select: none;
      pointer-events: none; /* text nebude br√°n jako klikac√≠ objekt */
    }
    #answer-options {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
    }
    #mode-blue, #mode-yellow {
      border: 2px solid #ccc;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 6px;
    }
.active-mode {
  border: 4px solid #333 !important;
}
.continue-btn-fixed-container {
       // position: sticky; /* P≈ôichyt√≠ prvek p≈ôi skrolov√°n√≠ */
        bottom: 0; /* P≈ôilep√≠ ho ke spodn√≠ ƒç√°sti okna prohl√≠≈æeƒçe/kontejneru */
       // margin-top: 20px;
        padding: 10px 0;
        background-color: white; /* Kl√≠ƒçov√©: zajist√≠, ≈æe p≈ôekryje obsah pod n√≠m */
        border-top: 1px solid #ccc;
        z-index: 100;
	width: 100%; 
        box-sizing: border-box; 
    }

  </style>
</head>

<body>
  <div id="jspsych-target" class="wrap"></div>

<script>

// ---------- jsPsych init ----------
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      // P≈Øvodn√≠: on_finish: () => jsPsych.data.displayData('json')
      on_finish: () => {
          // Z√≠sk√°n√≠ dat ve form√°tu Wide Format a jejich odesl√°n√≠
          const wideData = processDataForWideFormat(); 
          sendDataToSheetDB(wideData);
      }
    });


// Glob√°ln√≠ promƒõnn√° pro unik√°tn√≠ ID studenta a definice API
let subjectID = 'Student ' + (1000 + Math.floor(Math.random() * 900)).toString().substring(1);
const API_URL = 'https://sheetdb.io/api/v1/VLOZTE_SEM_VAS_API_ENDPOINT'; // ZDE VLO≈ΩTE V√Å≈† SKUTEƒåN√ù API ENDPOINT

function initializeStrategyButtons(answers, checkCompletion) {
    const strategyButtons = document.querySelectorAll('.strategy-btn');
    const strategyQuestionContainer = document.querySelector('.strategy-scale');
    
    let selectedStrategyValue = null;
    const otherTextarea = document.getElementById('text-other');
    
    strategyQuestionContainer.dataset.answer = '';

    if (otherTextarea) {
        otherTextarea.style.display = 'none';
        otherTextarea.value = '';
    }

    strategyButtons.forEach(button => {
        button.addEventListener('click', (event) => {
            event.preventDefault(); 
            
            strategyButtons.forEach(btn => {
                btn.classList.remove('selected');
                btn.style.background = '';
                btn.style.borderColor = '#ccc';
            });

            button.classList.add('selected');
            button.style.background = '#b3e0ff'; 
            button.style.borderColor = '#007bff'; 

            selectedStrategyValue = button.dataset.value;
            strategyQuestionContainer.dataset.answer = selectedStrategyValue;
            answers.strategy = selectedStrategyValue; // Ulo≈æ√≠ odpovƒõƒè
            checkCompletion();

            if (otherTextarea) {
                if (selectedStrategyValue === 'jiny duvod') {
                    otherTextarea.style.display = 'block';
                } else {
                    otherTextarea.style.display = 'none';
                    otherTextarea.value = '';
                }
            }
        });
    });
    
    // Nov√©: Listener pro textarea, aby vynutil checkCompletion (pro √∫pln√© ulo≈æen√≠)
    if (otherTextarea) {
         otherTextarea.addEventListener('input', () => {
             checkCompletion();
         });
    }
}

// Vylep≈°en√° a centr√°ln√≠ funkce pro p≈ôid√°n√≠ a obsluhu Likertovy sekce
function addLikertSection(containerId, continueButtonId, onComplete, includeStrategy = true) {
  const container = document.getElementById(containerId);
  if (!container) return;

  // Do hlavn√≠ho kontejneru √∫lohy vlo≈æ√≠me sekci s dotazn√≠kem
  let strategyHtml = '';
  if (includeStrategy) {
      strategyHtml = `
            <div class="likert-question">
                <p>3. Proƒç jsem mƒõnil/a sv≈Øj postup bƒõhem ≈ôe≈°en√≠ √∫lohy?</p>
                
               <div class="strategy-scale" data-question="strategy" style="display:flex; flex-direction: column; gap: 8px; max-width: 500px; margin: 0 auto;">

                        <button class="strategy-btn" data-value="nezmenena">Nemƒõnil/a jsem postup.</button>
                        <button class="strategy-btn" data-value="neefektivni">M≈Øj p≈Øvodn√≠ postup se uk√°zal jako neefektivn√≠.</button>
                        <button class="strategy-btn" data-value="proti zadani">M≈Øj p≈Øvodn√≠ postup neodpov√≠dal zad√°n√≠.</button>
                        <button class="strategy-btn" data-value="efektivnejsi">Objevil/a jsem efektivnƒõj≈°√≠ postup.</button>
                        <button class="strategy-btn" data-value="slepe misto">Nevƒõdƒõl/a jsem, jak pokraƒçovat s p≈Øvodn√≠m postupem, tak jsem zkusil/a jin√Ω.</button>
                        <button class="strategy-btn" data-value="jiny duvod">Jin√Ω d≈Øvod:</button>
                        <textarea id="text-other" placeholder="Pros√≠m popi≈°te" style="width: 80%; display: block; margin-left: 25px;"></textarea>
                </div>
            </div>
      `;
  }
  
  const section = document.createElement('div');
  section.innerHTML = `
    <div id="likert-section" style="margin-top:30px; padding: 15px; border: 1px solid #eee; border-radius: 8px; background-color: #f9f9f9;">
      <p><strong>Pros√≠m, odpovƒõz na n√°sleduj√≠c√≠ ot√°zky:</strong></p>

      <div class="likert-question" style="margin-bottom: 20px;">
        <p>1. Mysl√≠m, ≈æe m√© ≈ôe≈°en√≠ √∫lohy je spr√°vn√©.</p>
        <div class="likert-scale" data-question="confidence" style="display:flex; justify-content:space-around; flex-wrap:wrap; gap: 5px;"></div>
      </div>

      <div class="likert-question" style="margin-bottom: 20px;">
        <p>2. V minulosti u≈æ jsem podobnou √∫lohu ≈ôe≈°il/a.</p>
        <div class="likert-scale" data-question="familiarity" style="display:flex; justify-content:space-around; flex-wrap:wrap; gap: 5px;"></div>
      </div>
      
      <style>
          /* CSS styl pro zv√Ωraznƒõn√≠ vybran√© mo≈ænosti */
          .strategy-btn {
              padding: 10px;
              font-size: 16px;
              border: 2px solid #ccc;
              border-radius: 6px;
              cursor: pointer;
              text-align: left;
              transition: background-color 0.2s, border-color 0.2s;
              width: 100%; /* Zajist√≠ stejnou ≈°√≠≈ôku */
          }
          /* Styl pro vybran√© tlaƒç√≠tko */
          .strategy-btn.selected {
              background-color: #b3e0ff; /* Svƒõtle modr√° barva pro vybranou mo≈ænost */
              border-color: #007bff;
          }
      </style>
      
      ${strategyHtml}

    <div id="${continueButtonId}" class="continue-btn-fixed-container" style="display:none; text-align:center;">    
      <button class="jspsych-btn">Ulo≈æit a pokraƒçovat</button>
    </div>
  `;
  container.appendChild(section);

  const labels = [
    "Zcela souhlas√≠m", "Souhlas√≠m", "ƒå√°steƒçnƒõ souhlas√≠m", 
    "ƒå√°steƒçnƒõ nesouhlas√≠m", "Nesouhlas√≠m", "Zcela nesouhlas√≠m"
  ];

  // Vykreslen√≠ ≈°k√°l s popisky
  section.querySelectorAll('.likert-scale').forEach(scaleDiv => {
    // ... (logic for creating buttons is the same)
    const qKey = scaleDiv.dataset.question;
    
    labels.forEach((label, i) => {
      const btn = document.createElement('button');
      btn.textContent = `${label}`;
      btn.classList.add('likert-btn');
      btn.style.margin = '4px';
      btn.style.padding = '8px 10px';
      btn.style.fontSize = '14px';
      btn.style.flex = '1 1 15%'; 
      btn.dataset.value = i+1;
      btn.dataset.question = qKey;
      scaleDiv.appendChild(btn);
    });
  });

  const answers = { confidence: null, familiarity: null };
  if (includeStrategy) {
      answers.strategy = null;
  }
  
  const otherTextarea = document.getElementById('text-other');
  const continueBtnContainer = document.getElementById(continueButtonId);

  section.querySelectorAll('.likert-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      // ... (highlighting logic is the same)
      section.querySelectorAll(`.likert-btn[data-question="${btn.dataset.question}"]`)
        .forEach(b => b.style.background = '');
      btn.style.background = 'lightblue';
      answers[btn.dataset.question] = parseInt(btn.dataset.value);
      
      checkCompletion(); 
    });
  });
  
  function checkCompletion() {
      // Kontrola, zda jsou vyplnƒõn√© v≈°echny pot≈ôebn√© ot√°zky (v≈ædy MK1, MK2 + MK3 pokud existuje)
      let allAnswered = answers.confidence !== null && answers.familiarity !== null;
      
      if (includeStrategy) {
          allAnswered = allAnswered && answers.strategy !== null;
          // Pokud je vybr√°na "Jin√Ω d≈Øvod", zkontrolujeme i textov√© pole
          if (answers.strategy === 'jiny duvod' && otherTextarea) {
             allAnswered = allAnswered && otherTextarea.value.trim() !== '';
          }
      }

      if (allAnswered) {
          continueBtnContainer.style.display = 'block';
          continueBtnContainer.scrollIntoView({ 
              behavior: 'smooth', 
              block: 'end'
          });
      } else {
          continueBtnContainer.style.display = 'none'; 
      }
   }
  
  // Zpracov√°n√≠ kliknut√≠ na tlaƒç√≠tko "Ulo≈æit a pokraƒçovat"
  const continueBtnEl = document.querySelector(`#${continueButtonId} .jspsych-btn`);
  if(continueBtnEl) {
      continueBtnEl.addEventListener('click', () => {
          // Vytvo≈ô√≠me finalAnswers pro onComplete, vƒçetnƒõ textarea
          const finalAnswers = {
            confidence: answers.confidence,
            familiarity: answers.familiarity,
            strategy: answers.strategy || null,
            strategy_other: (answers.strategy === 'jiny duvod' && otherTextarea) ? otherTextarea.value : null
          };
          
          if (typeof onComplete === 'function') onComplete(finalAnswers);
          // Vymaz√°n√≠ a scroll
          const taskContainer = document.getElementById(containerId);
          if (taskContainer) {
             taskContainer.innerHTML = ''; 
          }
          window.scrollTo(0, 0);    
      });
  }
  
  if (includeStrategy) {
      initializeStrategyButtons(answers, checkCompletion);
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////


// ---------- Tituln√≠ strana ----------
const intro = {
    type: jsPsychHtmlButtonResponse,
    choices: [], // Odebr√°no standardn√≠ tlaƒç√≠tko
    stimulus: () => {
        return `
            <div id="intro-title-container" class="prompt">
                <h1>IGA 2025 Dotazn√≠k</h1>
                <p>Dƒõkujeme V√°m za √∫ƒçast ve v√Ωzkumu.</p>
                <div class="jspsych-btn-container" style="text-align: center; margin-top: 20px;">
                    <button id="continue-btn-intro" class="jspsych-btn">Pokraƒçovat</button>
                </div>
            </div>
        `;
    },
    on_load: () => {
        const container = document.getElementById('intro-title-container');
        const continueBtn = document.getElementById('continue-btn-intro');

        continueBtn.addEventListener('click', () => {
            if (container) {
                 container.innerHTML = ''; 
            }
            window.scrollTo(0, 0); 
            jsPsych.finishTrial();
        });
    }
};

// ---------- Souhlas s √∫ƒçast√≠ ve v√Ωzkumu (Informed Consent) ----------
const informed_consent = {
    type: jsPsychHtmlButtonResponse,
    
    // 1. D≈ÆLE≈ΩIT√â: Odebereme standardn√≠ tlaƒç√≠tka, aby se nezobrazilo to z jsPsych
    choices: [], 
    
    stimulus: () => {
        // 2. Do HTML p≈ôid√°me id kontejneru a vlastn√≠ tlaƒç√≠tko
        return `
            <div id="informed-consent-container" class="prompt">
                <h2>IGA 2025 Dotazn√≠k</h2>
                <p>Dƒõkujeme V√°m za √∫ƒçast ve v√Ωzkumu. P≈ôeƒçtƒõte si pros√≠m pozornƒõ n√°sleduj√≠c√≠ informace o v√Ωzkumu:</p>
                
                    Va≈°e √∫ƒçast ve v√Ωzkumu je zcela dobrovoln√°.
                    Data budou anonymizov√°na a pou≈æita v√Ωhradnƒõ pro vƒõdeck√© √∫ƒçely.
                    
                    Svou √∫ƒçast m≈Ø≈æete kdykoliv bez ud√°n√≠ d≈Øvodu ukonƒçit.
              
                <p><strong>Stisknut√≠m tlaƒç√≠tka ‚ÄûSouhlas√≠m a pokraƒçovat‚Äú potvrzujete, ≈æe jste si tyto informace p≈ôeƒçetli/a a souhlas√≠te s √∫ƒçast√≠.</strong></p>
                
                <div class="jspsych-btn-container" style="text-align: center; margin-top: 20px;">
                    <button id="continue-btn-consent" class="jspsych-btn">Souhlas√≠m a pokraƒçovat</button>
                </div>
            </div>
        `;
    },
    
    data: { task_name: 'informed_consent', consent: true },

    // 3. V on_load p≈ôid√°me obsluhu vlastn√≠ho tlaƒç√≠tka
    on_load: () => {
        const container = document.getElementById('informed-consent-container');
        const continueBtn = document.getElementById('continue-btn-consent');

        continueBtn.addEventListener('click', () => {
            // Data u≈æ jsou v bloku 'data', ale m≈Ø≈æeme zde p≈ôidat dal≈°√≠, pokud je pot≈ôeba.
            // Zde se jen p≈ôesuneme d√°l:

            // KROK A: VYƒåIST√çME KONTEJNER
            if (container) {
                 container.innerHTML = ''; 
            }

            // KROK B: Vynut√≠me scroll (pro plynulost)
            window.scrollTo(0, 0); 
            
            // KROK C: Dokonƒç√≠me trial a p≈ôejdeme na demografii
            jsPsych.finishTrial();
        });
    }
};


// ---------- Demografick√© ot√°zky: Obor studia ----------
const demography_study_field = {
    type: jsPsychHtmlButtonResponse,
    choices: [], // V√Ωchoz√≠ tlaƒç√≠tko bude skryt√©
    stimulus: () => {
        return `
            <div id="study-field-container">
                <div class="prompt">
                    <h2>Demografick√© √∫daje</h2>
                    <p>Jak√Ω je V√°≈° <strong>hlavn√≠ obor</strong> studia?</p>
                </div>
                <div style="text-align: left; margin: 20px auto; max-width: 400px;">
                    <label style="display: block; margin-bottom: 10px;">
                        <input type="radio" name="study_field" value="U1ST" style="margin-right: 8px;">
                        Uƒçitelstv√≠ pro 1. stupe≈à
                    </label>
                    <label style="display: block; margin-bottom: 10px;">
                        <input type="radio" name="study_field" value="U1SPN" style="margin-right: 8px;">
                        Uƒçitelstv√≠ pro 1. stupe≈à se speci√°ln√≠ pedagogikou
                    </label>
                    <label style="display: block; margin-bottom: 10px;">
                        <input type="radio" name="study_field" value="UMAT" style="margin-right: 8px;">
                        Uƒçitelstv√≠ pro 2. stupe≈à
                    </label>
                    <label style="display: block; margin-bottom: 10px;">
                        <input type="radio" name="study_field" value="Jiny" style="margin-right: 8px;">
                        Jin√Ω obor
                    </label>
                </div>
                <div class="jspsych-btn-container" style="text-align: center; margin-top: 20px;">
                <button id="continue-btn-demography" class="jspsych-btn" disabled>Pokraƒçovat</button>    
                </div>
            </div>
        `;
    },
    on_load: () => {
        const container = document.getElementById('study-field-container');
        const continueBtn = document.getElementById('continue-btn-demography');
        let selectedValue = null;

        container.querySelectorAll('input[name="study_field"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                selectedValue = e.target.value;
                continueBtn.disabled = false;
            });
        });

        continueBtn.addEventListener('click', () => {
            if (selectedValue !== null) {
                // Ulo≈æen√≠ dat
                jsPsych.data.addDataToLastTrial({
                    study_field: selectedValue,
                    task_name: 'demography'
                });

                // Vyƒçi≈°tƒõn√≠ a p≈ôechod (pro zachov√°n√≠ principu "ƒçist√©" str√°nky)
                container.innerHTML = '';
                window.scrollTo(0, 0);
                jsPsych.finishTrial();
            }
        });
    }
};

// ---------- Demografick√© ot√°zky: Roƒçn√≠k studia (dynamick√© mo≈ænosti) ----------
const demography_study_year = {
    type: jsPsychHtmlButtonResponse,
    // POZOR: Ponech√°me pr√°zdn√© choices, proto≈æe tlaƒç√≠tko generujeme ruƒçnƒõ v on_load
    choices: [], 
    stimulus: () => {
        return `
            <div id="study-year-container">
                <div class="prompt">
                    <h2>Demografick√© √∫daje</h2>
                    <p>Jak√Ω je <strong>roƒçn√≠k</strong> Va≈°eho studia?</p>
                </div>
                <div id="study-year-options" style="text-align: left; margin: 20px auto; max-width: 400px;">
                    <p>Mo≈ænosti se naƒç√≠taj√≠...</p>
                </div>
                <div class="jspsych-btn-container" style="text-align: center; margin-top: 20px;">
                    <button id="continue-btn-year" class="jspsych-btn" disabled>Pokraƒçovat</button>  
                </div>
            </div>
        `;
    },
    on_load: () => {
        const containerYear = document.getElementById('study-year-container');
        // OPRAVA CHYBY: P≈ôejmenov√°n√≠ promƒõnn√© na 'continueBtnYear'
        const continueBtnYear = document.getElementById('continue-btn-year');
        
        // 1. Z√≠sk√°n√≠ dat z p≈ôedchoz√≠ho trialu (Obor studia)
        const allData = jsPsych.data.get().values();
        // Spolehlivƒõ najdeme data z trialu s task_name: 'demography'
        const previousTrialData = allData.findLast(d => d.task_name === 'demography');
        
        // Z√≠sk√°me vybran√Ω obor (p≈ôedpokl√°d√° se, ≈æe je ulo≈æen pod 'study_field')
        const studyField = previousTrialData ? previousTrialData.study_field : null; 

        // 2. Definov√°n√≠ mo≈ænost√≠ odpovƒõd√≠ podle vƒõtve (UMAT vs. Ostatn√≠)
        let optionsHtml = '';
        let choices = [];

        if (studyField === 'UMAT') {
            // Vƒõtev Uƒçitelstv√≠ pro 2. stupe≈à (Bc. a Mgr.)
            choices = [
                { value: "1BC", label: "1. roƒçn√≠k v Bc." },
                { value: "2BC", label: "2. roƒçn√≠k Bc." },
                { value: "3BC", label: "3. roƒçn√≠k v Bc." },
                { value: "1MG", label: "1. roƒçn√≠k v Mgr." },
                { value: "2MG", label: "2. roƒçn√≠k v Mgr." }
            ];
        } else {
            // Ostatn√≠ obory (U1ST, U1SPN, Jiny, nebo pokud se nez√≠skal studyField)
            choices = [
                { value: "1", label: "1. roƒçn√≠k" },
                { value: "2", label: "2. roƒçn√≠k" },
                { value: "3", label: "3. roƒçn√≠k" },
                { value: "4", label: "4. roƒçn√≠k" },
                { value: "5", label: "5. roƒçn√≠k" }
            ];
        }

        // 3. Vygenerov√°n√≠ HTML pro radio buttony
        choices.forEach(option => {
            optionsHtml += `
                <label style="display: block; margin-bottom: 10px;">
                    <input type="radio" name="study_year" value="${option.value}" style="margin-right: 8px;">
                    ${option.label}
                </label>
            `;
        });
        
        // 4. Vlo≈æen√≠ HTML a obsluha volby
        const optionsContainer = document.getElementById('study-year-options');
        optionsContainer.innerHTML = optionsHtml;
        
        let selectedValue = null;
        
        optionsContainer.querySelectorAll('input[name="study_year"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                selectedValue = e.target.value;
                continueBtnYear.disabled = false; // Aktivujeme tlaƒç√≠tko
            });
        });

        // 5. Obsluha tlaƒç√≠tka "Pokraƒçovat"
        continueBtnYear.addEventListener('click', () => {
            if (selectedValue !== null) {
                // Ulo≈æ√≠me data o roƒçn√≠ku
                jsPsych.data.addDataToLastTrial({
                    study_year: selectedValue,
                    task_name: 'demography_year'
                });
                // Dokonƒç√≠me trial
                containerYear.innerHTML = '';
                window.scrollTo(0, 0);
                jsPsych.finishTrial();
            }
        });
    }
};

// ---------- Demografick√© ot√°zky: Forma studia ----------
const demography_study_form = {
    type: jsPsychHtmlButtonResponse,
    choices: [],
    stimulus: () => {
        return `
            <div id="study-form-container">
                <div class="prompt">
                    <h2>Demografick√© √∫daje</h2>
                    <p>Jak√° je <strong>forma</strong> Va≈°eho studia?</p>
                </div>
                <div style="text-align: left; margin: 20px auto; max-width: 400px;">
                    <label style="display: block; margin-bottom: 10px;">
                        <input type="radio" name="study_form" value="prezencni" style="margin-right: 8px;">
                        Prezenƒçn√≠
                    </label>
                    <label style="display: block; margin-bottom: 10px;">
                        <input type="radio" name="study_form" value="kombinovana" style="margin-right: 8px;">
                        Kombinovan√°
                    </label>
                </div>
                <div class="jspsych-btn-container" style="text-align: center; margin-top: 20px;">
                <button id="continue-btn-form" class="jspsych-btn" disabled>Pokraƒçovat</button>  
                </div>
            </div>
        `;
    },
    on_load: () => {
        const container = document.getElementById('study-form-container');
        const continueBtn = document.getElementById('continue-btn-form');
        let selectedValue = null;

        container.querySelectorAll('input[name="study_form"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                selectedValue = e.target.value;
                continueBtn.disabled = false; // Aktivujeme tlaƒç√≠tko
            });
        });

        continueBtn.addEventListener('click', () => {
            if (selectedValue !== null) {
                jsPsych.data.addDataToLastTrial({
                    study_form: selectedValue,
                    task_name: 'demography_form'
                });
                container.innerHTML = '';
                window.scrollTo(0, 0);
                jsPsych.finishTrial();
            }
        });
    }
};

////////////////////////////////////////////////////////// 1. √∫loha

   // ---------- Graf s p≈ôetahov√°n√≠m vrchol≈Ø ----------
    const initialVertices = [
      { id: 0, x: 120, y: 40 }, 
      { id: 1, x: 360, y: 40 }, 
      { id: 2, x: 120, y: 320 },
      { id: 3, x: 360, y: 320 },
      { id: 4, x: 208, y: 90 }, 
      { id: 5, x: 280, y: 110 }, 
      { id: 6, x: 200, y: 264 },
      { id: 7, x: 265, y: 230 }  
    ];

    // Hrany: [u, v]
    const edges = [
      [0,1], [0,2], [0,7],
      [1,4], [1,6], [1,7], [1,3],
      [2,4], [2,5],
      [3,6], [3,4], [3,5],
      [5,7]
    ];

    const houseTask = {
      type: jsPsychHtmlButtonResponse,
      choices: [], 
      stimulus: () => {
        // Zabaleno do nov√©ho kontejneru pro dotazn√≠k
        return `
          <div id="house-task-container">
            <div id="graphbox">
              <div class="prompt">
    		<p><strong>1. √öloha</strong></p> 
                <p><strong>Zad√°n√≠:</strong> P≈ôesu≈à body tak, aby se ƒç√°ry nek≈ô√≠≈æily.</p>
              </div>
              <svg id="graph" viewBox="0 0 480 360" preserveAspectRatio="xMidYMid meet" aria-label="Domeƒçek ‚Äì graf">
                ${edges.map(([u,v], i) => `<line class="edge" data-u="${u}" data-v="${v}" id="edge-${i}" x1="0" y1="0" x2="0" y2="0"></line>`).join('')}
                ${initialVertices.map(v => `
                  <g class="node" data-id="${v.id}" id="node-${v.id}">
                    <circle r="9" cx="${v.x}" cy="${v.y}"></circle>
                  </g>
                `).join('')}
              </svg>
              <div class="ui">
                <button type="button" id="reset-btn">Resetovat polohu</button>
                <span class="note">T√°hnƒõte punt√≠k za stisknut√© tlaƒç√≠tko my≈°i (nebo prstem na mobilu).</span>
              </div>
            </div>
          </div>
        `;
      },
      on_load: () => {
        const svg = document.getElementById('graph');
        const nodes = Array.from(svg.querySelectorAll('.node'));
        const lineEls = Array.from(svg.querySelectorAll('.edge'));
        
        let vertices = initialVertices.map(v => ({...v}));
        const startPositions = initialVertices.map(v => ({...v}));
        let resetCount = 0; // NOV√â: Poƒç√≠tadlo reset≈Ø

        function updateEdges() {
          for (const line of lineEls) {
            const u = +line.getAttribute('data-u');
            const v = +line.getAttribute('data-v');
            const a = vertices[u];
            const b = vertices[v];
            line.setAttribute('x1', a.x);
            line.setAttribute('y1', a.y);
            line.setAttribute('x2', b.x);
            line.setAttribute('y2', b.y);
          }
        }

        function updateNodePosition(el, x, y) {
          const minX = 10, minY = 10, maxX = 470, maxY = 350;
          const nx = Math.max(minX, Math.min(maxX, x));
          const ny = Math.max(minY, Math.min(maxY, y));
          const id = +el.getAttribute('data-id');
          vertices[id].x = nx;
          vertices[id].y = ny;
          const circle = el.querySelector('circle');
          circle.setAttribute('cx', nx);
          circle.setAttribute('cy', ny);
        }

        function clientToSvgPoint(svgEl, clientX, clientY) {
          const pt = svgEl.createSVGPoint();
          pt.x = clientX; pt.y = clientY;
          const matrix = svgEl.getScreenCTM().inverse();
          return pt.matrixTransform(matrix);
        }

        let dragging = null;

        function pointerDown(e) {
          e.preventDefault();
          const target = e.currentTarget; 
          dragging = target;
          target.classList.add('dragging');
          target.setPointerCapture?.(e.pointerId);
        }
        function pointerMove(e) {
          if (!dragging) return;
          const p = clientToSvgPoint(svg, e.clientX, e.clientY);
          updateNodePosition(dragging, p.x, p.y);
          updateEdges();
        }
        function pointerUp(e) {
          if (!dragging) return;
          dragging.classList.remove('dragging');
          dragging.releasePointerCapture?.(e.pointerId);
          dragging = null;
        }

        nodes.forEach(n => {
          n.addEventListener('pointerdown', pointerDown);
        });
        svg.addEventListener('pointermove', pointerMove);
        window.addEventListener('pointerup', pointerUp);

        function applyPositions(pos) {
          vertices = pos.map(v => ({...v}));
          vertices.forEach(v => {
            const g = document.getElementById('node-' + v.id);
            const c = g.querySelector('circle');
            c.setAttribute('cx', v.x);
            c.setAttribute('cy', v.y);
          });
          updateEdges();
        }

		  nodes.forEach(n => {
          n.addEventListener('pointerdown', pointerDown);
        });
        svg.addEventListener('pointermove', pointerMove);
        window.addEventListener('pointerup', pointerUp);
		  
        applyPositions(vertices);
		  
        document.getElementById('reset-btn').addEventListener('click', () => {
          applyPositions(startPositions);
          resetCount++; // NOV√â: Inkrementace poƒç√≠tadla
        });

        // --- P≈òID√ÅN√ç LIKERTOVY SEKCE A LOGIKY ULO≈ΩEN√ç DAT ---
        addLikertSection('house-task-container', 'continue-btn-house', (likertAnswers) => {
            // Ulo≈æen√≠ dat ve form√°tu pro mapov√°n√≠
            jsPsych.data.addDataToLastTrial({
                task_name: 'houseTask', 
                vertices: vertices.map(v => ({ id: v.id, x: Math.round(v.x), y: Math.round(v.y) })), // task1_solution
                reset_count: resetCount, // task1_reset
                ...likertAnswers // MK1, MK2, strategy, strategy_other
            });
            jsPsych.finishTrial();
        });
    },
};
	
//////////////////////////////////////////////////////////////////// 2. √∫loha
const connectTask = {
    type: jsPsychHtmlButtonResponse,
    choices: [], 
    
    // Stimulus (HTML) - BEZ TLAƒå√çTKA RESET
    stimulus: () => {
        return `
            <div id="connect-task-container">
                <div id="graphbox">
                    <div class="prompt">
                        <p><strong>2. √∫loha:</strong> Spojte koleƒçka ƒçarami tak, aby poƒçet ƒçar, kter√© jsou s koleƒçkem spojeny odpov√≠dal ƒç√≠slu, kter√© je uvnit≈ô napsan√©. Kliknƒõte na dva body, aby se vytvo≈ôila nebo smazala ƒç√°ra.</p>
                    </div>
                    <svg id="connect-graph" viewBox="0 0 480 360" preserveAspectRatio="xMidYMid meet" aria-label="Spojov√°n√≠ vrchol≈Ø">
                    </svg>
                    <div class="ui">
                        <span class="note">Kliknƒõte na dva body pro spojen√≠/odpojen√≠.</span>
                    </div>
                </div>
            </div>
        `;
    },
    
    on_load: () => {
        const svg = document.getElementById('connect-graph');
        
        // --- KONTROLA P√ÅDU K√ìDU ---
        if (!svg) {
            console.error("Chyba: Grafick√Ω kontejner (SVG) nebyl nalezen.");
            return; 
        }

        const svgNS = "http://www.w3.org/2000/svg";

        // üö® ZDE JE OPRAVA CHYBY selectedNode A V√Å≈† P≈ÆVODN√ç GRAF üö®
        let edges = []; // vytvo≈ôen√© hrany
        let selectedNode = null; // Deklarace pro zamezen√≠ ReferenceError

        // V√Å≈† P≈ÆVODN√ç GRAF:
        const vertices = [
            { id: 0, x: 240, y: 60, degree: 2 }, 
            { id: 1, x: 140, y: 120, degree: 4 }, 
            { id: 2, x: 340, y: 120, degree: 2 },
            { id: 3, x: 140, y: 240, degree: 4 },
            { id: 4, x: 340, y: 240, degree: 2 },
            { id: 5, x: 240, y: 300, degree: 4 }
        ];

        // Funkce pro vykreslen√≠ grafu (vƒçetnƒõ hrany, vrchol≈Ø a ƒç√≠sel)
        function drawGraph() {
            // Smazat v≈°e kromƒõ SVG (pro re-render)
            Array.from(svg.children).forEach(el => el.remove());

            // Vykreslit existuj√≠c√≠ hrany
            edges.forEach(edge => {
                const n1 = vertices.find(v => v.id === edge.from);
                const n2 = vertices.find(v => v.id === edge.to);
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', n1.x);
                line.setAttribute('y1', n1.y);
                line.setAttribute('x2', n2.x);
                line.setAttribute('y2', n2.y);
                line.setAttribute('stroke', '#000000');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            });

            // Vykreslit vrcholy a ƒç√≠seln√© ≈°t√≠tky
            vertices.forEach(node => {
                // Kruh
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 20);
                circle.setAttribute('fill', selectedNode === node.id ? 'lightblue' : 'white'); 
                circle.setAttribute('stroke', 'black');
                circle.setAttribute('stroke-width', '2');
                circle.style.cursor = 'pointer';
                circle.setAttribute('data-node-id', node.id); 
                svg.appendChild(circle);

                // ƒå√≠slo (stupe≈à)
                const text = document.createElementNS(svgNS, 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y + 5); 
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', 'black');
                text.setAttribute('font-size', '14');
                text.textContent = node.degree;
                svg.appendChild(text);

                // Logika kliknut√≠
                circle.addEventListener('click', () => {
                    if (selectedNode === null) {
                        // Prvn√≠ klik
                        selectedNode = node.id;
                    } else {
                        // Druh√Ω klik
                        if (selectedNode !== node.id) {
                            const existsIndex = edges.findIndex(e => 
                                (e.from === selectedNode && e.to === node.id) || 
                                (e.from === node.id && e.to === selectedNode)
                            );
                            
                            if (existsIndex >= 0) {
                                // Hrana existuje -> Smazat (odpojit)
                                edges.splice(existsIndex, 1);
                            } else {
                                // Hrana neexistuje -> Vytvo≈ôit (spojit)
                                edges.push({ from: selectedNode, to: node.id });
                            }
                        }
                        
                        selectedNode = null; // Reset v√Ωbƒõru
                        drawGraph(); // P≈ôekreslit
                    }
                });
            });
        }

        // Prvn√≠ vykreslen√≠ grafu
        drawGraph();

        // --- P≈òID√ÅN√ç LIKERTOVY SEKCE A LOGIKY ULO≈ΩEN√ç DAT ---
        addLikertSection('connect-task-container', 'continue-btn-connect', (likertAnswers) => {
            
            // 1. Ulo≈æ√≠me data do jsPsych
            jsPsych.data.addDataToLastTrial({
                task_name: 'connectTask',
                created_edges: edges, // task2_solution
                ...likertAnswers // MK odpovƒõdi
            });
            
            // 2. MANU√ÅLN√ç SMAZ√ÅN√ç KONTEJNERU √öLOHY 2 (Kl√≠ƒçov√© pro p≈ôechod na √ölohu 3)
            const container = document.getElementById('connect-task-container');
            if (container) {
                container.remove();
            }

            // 3. Ukonƒç√≠me trial
            jsPsych.finishTrial();
        });
    }
};
	
///////////////////////////////////////////////////////////////// 3. √∫loha	
const coloringTask = {
  type: jsPsychHtmlButtonResponse,
  choices: [],
  stimulus: () => {
    return `
      <div id="coloring-task-container"> <div class="prompt">
          <p><strong>3. √∫loha:</strong> Vybarvƒõte koleƒçka tak, aby ka≈æd√° dvƒõ, kter√° jsou spojen√°, mƒõla rozd√≠lnou barvu.</p>
        </div>
        <div style="display:flex; gap:20px;">
          <svg id="color-graph" viewBox="0 0 500 360" preserveAspectRatio="xMidYMid meet" style="flex:2; border:1px solid #ccc;"></svg>
    
          <div id="color-panel" style="flex:1; display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center;"></div>
        </div>
        <div style="margin-top:10px;">
          <button type="button" id="reset-coloring">Resetovat barvy</button>
        </div>
        
        <div class="question" style="margin-top:20px;">
          <p>Kolik barev nejm√©nƒõ je pot≈ôeba pou≈æ√≠t pro vybarven√≠ obr√°zku tak, aby dvƒõ spojen√° koleƒçka mƒõla v≈ædy jinou barvu?</p>
          <div id="answer-options" style="display:flex; gap:10px; margin-top:10px;"></div>
        </div>
        
        </div>
    `;
  },
  on_load: () => {
    const svg = document.getElementById('color-graph');
    const svgNS = "http://www.w3.org/2000/svg";

    const initialVertices = [
      { id: 0, x: 240, y: 40 }, 
      { id: 1, x: 180, y: 160 }, 
      { id: 2, x: 300, y: 160 },
      { id: 3, x: 270, y: 230 },
      { id: 4, x: 125, y: 300 }, 
      { id: 5, x: 240, y: 300 }, 
      { id: 6, x: 355, y: 300 } 
    ];

    const edges = [
      [0,1], [0,2],
      [1,2], [1,3], [1,4], [1,5],
      [2,3], [2,6],
      [3,5],
      [4,5],
      [5,6]
    ];

 	const vertexColors = {}; // {id: color}
    let selectedColor = null;
    let resetCount = 0; // Poƒç√≠tadlo reset≈Ø
    let chosenAnswer = null; // Odpovƒõƒè na ot√°zku poƒçtu barev
	const colors = ['red', 'green', 'blue', 'orange', 'purple'];
	  
    // Vykreslen√≠ hran
    edges.forEach(([u,v]) => {
      const n1 = initialVertices[u];
      const n2 = initialVertices[v];
      const line = document.createElementNS(svgNS, 'line');
      line.setAttribute('x1', n1.x);
      line.setAttribute('y1', n1.y);
      line.setAttribute('x2', n2.x);
      line.setAttribute('y2', n2.y);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '2');
      svg.appendChild(line);
    });

    // Vykreslen√≠ vrchol≈Ø
    initialVertices.forEach(node => {
      const circle = document.createElementNS(svgNS, 'circle');
      circle.setAttribute('cx', node.x);
      circle.setAttribute('cy', node.y);
      circle.setAttribute('r', 18);
      circle.setAttribute('fill', 'white');
      circle.setAttribute('stroke', 'black');
      circle.setAttribute('stroke-width', '2');
      circle.style.cursor = 'pointer';

      circle.addEventListener('click', () => {
        if (selectedColor) {
          vertexColors[node.id] = selectedColor;
          circle.setAttribute('fill', selectedColor);
        }
      });

      svg.appendChild(circle);
    });

    // Panel barev
    const colorPanel = document.getElementById('color-panel');
    colors.forEach(color => {
      const colorCircle = document.createElement('div');
      colorCircle.style.width = '36px';
      colorCircle.style.height = '36px';
      colorCircle.style.borderRadius = '50%';
      colorCircle.style.backgroundColor = color;
      colorCircle.style.border = '2px solid black';
      colorCircle.style.cursor = 'pointer';

      colorCircle.addEventListener('click', () => {
        selectedColor = color;
        // Zv√Ωraznƒõn√≠ vybran√©ho
        Array.from(colorPanel.children).forEach(c => {
          c.style.border = '2px solid black';
        });
        colorCircle.style.border = '4px solid #333';
      });

      colorPanel.appendChild(colorCircle);
    });
    
    // Reset barvy
        document.getElementById('reset-coloring').addEventListener('click', () => {
          initialVertices.forEach(node => {
            document.querySelector(`circle[cx="${node.x}"][cy="${node.y}"]`).setAttribute('fill', 'white');
            delete vertexColors[node.id];
          });
          resetCount++; // NOV√â: Inkrementace poƒç√≠tadla
        });

    // Odpovƒõdi 1-5 pro poƒçet barev
        const answers = [1,2,3,4,5];
        const answerContainer = document.getElementById('answer-options');
        answers.forEach(ans => {
            const btn = document.createElement('button');
            btn.className = 'jspsych-btn';
            btn.textContent = ans;
            btn.addEventListener('click', () => {
                chosenAnswer = ans; // NOV√â: Ulo≈æen√≠ odpovƒõdi
                Array.from(answerContainer.children).forEach(b => {
                    b.style.backgroundColor = '';
                }); 
                btn.style.backgroundColor = 'lightblue';
            });
            answerContainer.appendChild(btn);
        });

    // <<< P≈òID√ÅN√ç LIKERTOVY SEKCE A LOGIKY ULO≈ΩEN√ç DAT >>>
        // NOV√â: Vol√°n√≠ s includeStrategy = false (Task 3 m√° jen MK1 a MK2)
        addLikertSection('coloring-task-container', 'continue-btn-coloring', (likertAnswers) => {
            // Ulo≈æ√≠me data √∫kolu (barvy vrchol≈Ø, zvolen√° odpovƒõƒè) + data z dotazn√≠ku
            jsPsych.data.addDataToLastTrial({
                task_name: 'coloringTask', 
                vertex_colors: vertexColors, // task3_solution
                chosen_answer: chosenAnswer, // task3_answer
                reset_count: resetCount, // task3_reset
                confidence: likertAnswers.confidence, // task3_MK1
                familiarity: likertAnswers.familiarity, // task3_MK2
                // strategy a strategy_other jsou automaticky null/nevy≈æadovan√©
            });
            jsPsych.finishTrial();
        }, false); // NEZAHRNUT√ç MK3
    }
};

/////////////////////////////////////////////////////////////////////////// 4. √∫loha
const eulerTask = {
  type: jsPsychHtmlButtonResponse,
  choices: [],
  stimulus: () => {
    return `
      <div id="euler-task-container"> <div class="prompt">
          <p><strong>4. √∫loha:</strong> P≈ôidejte 1 ƒç√°ru tak, aby bylo mo≈æn√© obr√°zek nakreslit jedn√≠m tahem.</p>
        </div>
        <div style="margin-bottom:10px; display:flex; gap:10px; justify-content:center;">
          <button type="button" id="mode-blue" style="background:#4C8CFF; color:white;">Vytvo≈ôit nov√© ƒç√°ry</button>
          <button type="button" id="mode-yellow" style="background:#FFD700; color:black;">Nakreslit jedn√≠m tahem</button>
        </div>
        <svg id="euler-graph" viewBox="0 0 480 360" preserveAspectRatio="xMidYMid meet" style="border:1px solid #ccc;"></svg>
      </div>
    `;
  },
  on_load: () => {
    const svg = document.getElementById('euler-graph');
    const svgNS = "http://www.w3.org/2000/svg";

    const initialVertices = [
      { id: 0, x: 140, y: 55 }, 
      { id: 1, x: 340, y: 55 }, 
      { id: 2, x: 140, y: 305 },
      { id: 3, x: 340, y: 305 },
      { id: 4, x: 190, y: 140 }, 
      { id: 5, x: 270, y: 160 }, 
      { id: 6, x: 400, y: 170 },
      { id: 7, x: 280, y: 250 }
    ];

    const baseEdges = [
      [0,1], [0,2], [0,5],
      [1,3], [1,4], [1,5], [1,6],
      [2,3],
      [4,7]
    ];

    let blueEdges = []; // p≈ôidan√© modr√© hrany
    let yellowEdges = []; // ≈ælut√© hrany
	let yellowPathDrawn = false; //stav nakreslen√≠ ≈ælut√© trasy (new)
    let yellowEdgesOrder = []; // po≈ôad√≠ pro jednosmƒõrn√Ω tah
    let selectedNode = null; // pro modr√Ω re≈æim
    let lastYellowNode = null; // pro ≈ælut√Ω re≈æim
    let mode = null;

    // Vykreslit z√°kladn√≠ ƒçern√© hrany
    baseEdges.forEach(([u,v]) => {
      const n1 = initialVertices[u];
      const n2 = initialVertices[v];
      const line = document.createElementNS(svgNS, 'line');
      line.setAttribute('x1', n1.x);
      line.setAttribute('y1', n1.y);
      line.setAttribute('x2', n2.x);
      line.setAttribute('y2', n2.y);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '2');
      svg.appendChild(line);
    });

    // Vykreslit vrcholy
    initialVertices.forEach(node => {
      const circle = document.createElementNS(svgNS, 'circle');
      circle.setAttribute('cx', node.x);
      circle.setAttribute('cy', node.y);
      circle.setAttribute('r', 11);
      circle.setAttribute('fill', 'white');
      circle.setAttribute('stroke', 'black');
      circle.setAttribute('stroke-width', '2');
      circle.style.cursor = 'pointer';

      circle.addEventListener('click', () => {
        if (mode === 'blue') {
          if (selectedNode === null) {
            selectedNode = node.id;
            circle.setAttribute('fill', 'lightblue');
          } else {
            if (selectedNode !== node.id) {
              const existsInBase = baseEdges.some(([a,b]) => (a===selectedNode && b===node.id) || (a===node.id && b===selectedNode));
              const existsInBlue = blueEdges.findIndex(e => (e.from === selectedNode && e.to === node.id) || (e.from === node.id && e.to === selectedNode));
              if (!existsInBase) {
                if (existsInBlue >= 0) {
                  blueEdges.splice(existsInBlue, 1);
                } else {
                  // Omezen√≠, ≈æe lze p≈ôidat pouze 1 modrou ƒç√°ru
                  if (blueEdges.length < 1) { 
                      blueEdges.push({from:selectedNode, to:node.id});
                  }
                }
                drawBlueEdges();
              }
            }
            resetVertexColors();
            selectedNode = null;
          }
        }

        if (mode === 'yellow') {
          if (lastYellowNode === null) {
            lastYellowNode = node.id;
            circle.setAttribute('fill', '#FFFACD'); // svƒõtle ≈ælut√°
          } else {
            if (lastYellowNode !== node.id) {
              const existsInYellow = yellowEdges.findIndex(e => (e.from === lastYellowNode && e.to === node.id) || (e.from === node.id && e.to === lastYellowNode));
              // Logika ovƒõ≈ôen√≠, ≈æe hrana existuje (buƒè ƒçern√° nebo modr√°)
              const edgesToCheck = [...baseEdges, ...blueEdges.map(e => [e.from, e.to])];
              const edgeExists = edgesToCheck.some(([u,v]) => (u === lastYellowNode && v === node.id) || (v === lastYellowNode && u === node.id));

              if (edgeExists && existsInYellow < 0) {
                yellowEdges.push({from:lastYellowNode, to:node.id});
                yellowEdgesOrder.push([lastYellowNode,node.id]);
                drawYellowEdges();
              } else if (existsInYellow >= 0) {
                // Mo≈æn√° byste chtƒõl umo≈ænit smaz√°n√≠ posledn√≠ho tahu, ale zjednodu≈°√≠me to
                // Zde se jen p≈ôeskoƒç√≠, pokud ji≈æ existuje
              }
              
              resetVertexColors();
              const newCircle = svg.querySelectorAll('circle')[node.id];
              newCircle.setAttribute('fill', '#FFFACD');
              lastYellowNode = node.id;
            }
          }
        }
      });

      svg.appendChild(circle);
    });

    function resetVertexColors() {
      const circles = svg.querySelectorAll('circle');
      circles.forEach(c => c.setAttribute('fill','white'));
    }

    function drawBlueEdges() {
      // ... (funkce drawBlueEdges z≈Øst√°v√° stejn√°) ...
      svg.querySelectorAll('.blue-edge').forEach(el => el.remove());
      blueEdges.forEach(edge => {
        const n1 = initialVertices[edge.from];
        const n2 = initialVertices[edge.to];
        const r = 11; // polomƒõr vrcholu
        const dx = n2.x - n1.x;
        const dy = n2.y - n1.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        const startX = n1.x + (dx / d) * r;
        const startY = n1.y + (dy / d) * r;
        const endX = n2.x - (dx / d) * r;
        const endY = n2.y - (dy / d) * r;

        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', startX);
        line.setAttribute('y1', startY);
        line.setAttribute('x2', endX);
        line.setAttribute('y2', endY);
        line.setAttribute('stroke', '#4C8CFF');
        line.setAttribute('stroke-width', '3');
        line.classList.add('blue-edge');
        svg.appendChild(line);
      });
    }

    function drawYellowEdges() {
      // ... (funkce drawYellowEdges z≈Øst√°v√° stejn√°) ...
      svg.querySelectorAll('.yellow-edge').forEach(el => el.remove());
      yellowEdges.forEach(edge => {
        const n1 = initialVertices[edge.from];
        const n2 = initialVertices[edge.to];
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', n1.x);
        line.setAttribute('y1', n1.y);
        line.setAttribute('x2', n2.x);
        line.setAttribute('y2', n2.y);
        line.setAttribute('stroke', '#FFD700');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-opacity', '0.6'); 
        line.classList.add('yellow-edge');
        svg.appendChild(line);
      });
    }

    // P≈ôep√≠n√°n√≠ re≈æim≈Ø
    const btnBlue = document.getElementById('mode-blue');
    const btnYellow = document.getElementById('mode-yellow');

    btnBlue.addEventListener('click', () => {
      mode = 'blue';
      btnBlue.classList.add('active-mode');
      btnYellow.classList.remove('active-mode');

      yellowEdges = [];
      yellowEdgesOrder = [];
      drawYellowEdges();
      lastYellowNode = null;
      resetVertexColors();
    });

    btnYellow.addEventListener('click', () => {
      mode = 'yellow';
      btnYellow.classList.add('active-mode');
      btnBlue.classList.remove('active-mode');

      lastYellowNode = null;
      resetVertexColors();
    });

    // P≈Øvodn√≠ k√≥d pro ulo≈æen√≠ dat BYL ZDE ODSTRANƒöN a nahrazen vol√°n√≠m funkce addLikertSection!

    // --- P≈òID√ÅN√ç LIKERTOVY SEKCE A LOGIKY ULO≈ΩEN√ç DAT ---
        addLikertSection('euler-task-container', 'continue-btn-euler', (likertAnswers) => {
            
            // 1. Ulo≈æ√≠me data do jsPsych
            jsPsych.data.addDataToLastTrial({
                task_name: 'eulerTask', 
                blue_edges: blueEdges,          // task4_solution: Modr√© hrany (nap≈ô. [{from: 1, to: 4}])
                yellow_path_drawn: yellowPathDrawn, // task4_yellow: Zda byla zkusena ≈ælut√° trasa (boolean)
                ...likertAnswers                // task4_MK1, task4_MK2, task4_MK3 (+ strategy_other)
            });
            
            // 2. Ukonƒç√≠me trial
            jsPsych.finishTrial();
        });
    }
};

/////////////////////////////////////////////////////////////////// 5. √∫loha
const hamiltonTask = {
  type: jsPsychHtmlButtonResponse,
  choices: [], // Zmƒõna: Odebr√°no defaultn√≠ tlaƒç√≠tko
  stimulus: () => {
    return `
      <div id="hamilton-task-container"> <div class="prompt">
          <p><strong>5. √∫loha:</strong> Najdi cestu mapou jedn√≠m tahem tak, aby ka≈æd√© mƒõsto (bod) pro≈°la pr√°vƒõ jednou.</p>
        </div>
        <div style="margin-bottom:10px; display:flex; justify-content:center;">
          <button type="button" id="reset-path">Vymazat trasu</button>
        </div>
        <svg id="hamilton-graph" viewBox="0 0 480 360" preserveAspectRatio="xMidYMid meet" style="border:1px solid #ccc; display:block; margin:auto;"></svg>
        <span class="note">Kliknƒõte na dva body, aby se mezi nimi vytvo≈ôila cesta.</span>
        
        </div>
    `;
  },
  on_load: () => {
    const svg = document.getElementById('hamilton-graph');
    const svgNS = "http://www.w3.org/2000/svg";

    const initialVertices = [
      { id: 0, x: 240, y: 60 }, 
      { id: 1, x: 120, y: 120 }, 
      { id: 2, x: 360, y: 120 },
      { id: 3, x: 80, y: 180 },
      { id: 4, x: 160, y: 180 }, 
      { id: 5, x: 240, y: 180 }, 
      { id: 6, x: 320, y: 180 },
      { id: 7, x: 400, y: 180 },
      { id: 8, x: 120, y: 240 },
      { id: 9, x: 360, y: 240 },
      { id: 10, x: 240, y: 300 }
    ];

    const edges = [
      [0,2], [0,4], [0,5],
      [1,2], [1,3], [1,4],
      [2,5], [2,9],
      [3,4], [3,8],
      [4,10],
      [5,8], [5,9],
      [6,7], [6,10],
      [7,9],
      [8,9], [8,10]
    ];

    let yellowEdges = [];
    let yellowEdgesOrder = [];
    let lastNode = null;
	let resetCount = 0;

    // vykresl√≠me ƒçern√© hrany
    edges.forEach(([u,v]) => {
      const n1 = initialVertices[u];
      const n2 = initialVertices[v];
      const line = document.createElementNS(svgNS, 'line');
      line.setAttribute('x1', n1.x);
      line.setAttribute('y1', n1.y);
      line.setAttribute('x2', n2.x);
      line.setAttribute('y2', n2.y);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '2');
      svg.appendChild(line);
    });

    // vykresl√≠me vrcholy
    initialVertices.forEach(node => {
      const circle = document.createElementNS(svgNS, 'circle');
      circle.setAttribute('cx', node.x);
      circle.setAttribute('cy', node.y);
      circle.setAttribute('r', 9); 
      circle.setAttribute('fill', 'white');
      circle.setAttribute('stroke', 'black');
      circle.setAttribute('stroke-width', '2');
      circle.style.cursor = 'pointer';

      circle.addEventListener('click', () => {
        if (lastNode === null) {
          lastNode = node.id;
          circle.setAttribute('fill', '#FFFACD'); // svƒõtle ≈ælut√°
        } else {
          if (lastNode !== node.id) {
            const exists = yellowEdges.findIndex(e =>
              (e.from === lastNode && e.to === node.id) ||
              (e.from === node.id && e.to === lastNode)
            );
            const existsInBase = edges.some(([a,b]) =>
              (a === lastNode && b === node.id) ||
              (a === node.id && b === lastNode)
            );
            if (exists < 0 && existsInBase) {
              yellowEdges.push({from:lastNode, to:node.id});
              yellowEdgesOrder.push([lastNode, node.id]);
              drawYellowEdges();
            }
            resetVertexColors();
            const newCircle = svg.querySelectorAll('circle')[node.id];
            newCircle.setAttribute('fill', '#FFFACD');
            lastNode = node.id;
          }
        }
      });

      svg.appendChild(circle);
    });

    function resetVertexColors() {
      const circles = svg.querySelectorAll('circle');
      circles.forEach(c => c.setAttribute('fill','white'));
    }

    function drawYellowEdges() {
      svg.querySelectorAll('.yellow-edge').forEach(el => el.remove());
      yellowEdges.forEach(edge => {
        const n1 = initialVertices[edge.from];
        const n2 = initialVertices[edge.to];
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', n1.x);
        line.setAttribute('y1', n1.y);
        line.setAttribute('x2', n2.x);
        line.setAttribute('y2', n2.y);
        line.setAttribute('stroke', '#FFD700');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-opacity', '0.6'); // pr≈Øhlednost
        line.classList.add('yellow-edge');
        svg.appendChild(line);
      });
    }

    // Vymazat trasu
    document.getElementById('reset-path').addEventListener('click', () => {
      yellowEdges = [];
      yellowEdgesOrder = [];
      svg.querySelectorAll('.yellow-edge').forEach(el => el.remove());
      resetVertexColors();
      lastNode = null;
	  resetCount++;
    });

    
    // =====================================================================
    // <<< P≈òID√ÅN√ç LIKERTOVY SEKCE A LOGIKY ULO≈ΩEN√ç DAT >>>
    // =====================================================================
    addLikertSection('hamilton-task-container', 'continue-btn-hamilton', (likertAnswers) => {
        // Ulo≈æ√≠me data √∫kolu (≈ælut√° trasa) + data z dotazn√≠ku
        jsPsych.data.addDataToLastTrial({
            task_name: 'pathfindingTask', // Spr√°vn√Ω n√°zev, kter√Ω pou≈æ√≠v√°me v processDataForWideFormat
            
            // task5_solution: popsan√° trasa v po≈ôad√≠ hran
            final_path: yellowEdgesOrder.map(([from, to]) => ({from, to})), 
            
            // task5_resett: Poƒçet kliknut√≠ na "Vymazat trasu"
            reset_count: resetCount,
            
            ...likertAnswers // task5_MK1, task5_MK2, task5_MK3 (+ strategy_other)
        });
        jsPsych.finishTrial();
    });
  }
};
	

// =========================================================================
// P≈òEPRACOVAN√Å FUNKCE PRO ODESL√ÅN√ç DAT VE WIDE FORM√ÅTU
// =========================================================================

// GLOB√ÅLN√ç ƒå√çTAƒå PRO IDENTIFIKACI RESPONDENT≈Æ (lze ho ulo≈æit i v LocalStorage)
// Pro jednoduchost ho nech√°me jako ƒçasov√© raz√≠tko.
let respondentCounter = 0; 

function saveDataToSheetDB() {
    // 1. Nastaven√≠ promƒõnn√Ωch
    const sheetDB_URL = 'o	https://sheetdb.io/api/v1/dknmz514rz0f5'; // ZMƒö≈áTE NA VA≈†I URL!
    const allData = jsPsych.data.get().values();
    
    // Generov√°n√≠ ID (nap≈ô. "ID_1667678400000" pro dne≈°n√≠ datum/ƒças)
    const subjectID = 'ID_' + Date.now(); 
    
    // Jedin√Ω objekt pro fin√°ln√≠ ulo≈æen√≠ (jeden ≈ô√°dek v tabulce)
    const finalData = {
        respondent_id: subjectID,
        time_total_ms: jsPsych.data.get().select('time_elapsed').values().at(-1) || 'N/A'
    };

    // Index pro pojmenov√°n√≠ √∫kol≈Ø (task1, task2, ...)
    let taskIndex = 1; 

    // 2. Extrakce a form√°tov√°n√≠ dat do WIDE FORMATU
    allData.forEach(trial => {
        // --- A. Demografick√© √∫daje ---
        // Demografick√© √∫daje ukl√°d√°me jen jednou
        if (trial.task_name === 'demography' && !finalData.study_field) {
            finalData.study_field = trial.study_field;
        }
        if (trial.task_name === 'demography_year' && !finalData.study_year) {
            finalData.study_year = trial.study_year;
        }
        
        // --- B. √ökoly (Sledov√°n√≠ pohybu, odpovƒõƒè a Likertovy ot√°zky) ---
        // P≈ôedpokl√°d√°me, ≈æe √∫koly maj√≠ unik√°tn√≠ data: yellow_path
        if (trial.yellow_path) { 
            const prefix = `task${taskIndex}_`;
            
            finalData[prefix + 'rt'] = trial.rt;
            finalData[prefix + 'path'] = JSON.stringify(trial.yellow_path); // Sledovan√° cesta
            finalData[prefix + 'answer'] = trial.answer; // Koneƒçn√° volba (slovn√≠ odpovƒõƒè)
            
            // Likertovy ot√°zky (zde se fixuje probl√©m s chybƒõj√≠c√≠mi daty)
            finalData[prefix + 'L_time'] = trial.likert_time || 'N/A'; 
            finalData[prefix + 'L_diff'] = trial.likert_difficulty || 'N/A';
            finalData[prefix + 'L_cert'] = trial.likert_certainty || 'N/A';

            taskIndex++;
        }
        
        // --- C. Fin√°ln√≠ slovn√≠ odpovƒõƒè (Slovn√≠ reflexe) ---
        // V√°≈° k√≥d mo≈æn√° obsahuje trial, kde je ulo≈æena del≈°√≠ slovn√≠ odpovƒõƒè.
        // P≈ôedpokl√°dejme, ≈æe je ulo≈æena pod kl√≠ƒçem 'text_response' a 'task_name: "final_reflection"'
        if (trial.task_name === 'final_reflection' && trial.text_response) {
            finalData.final_reflection = trial.text_response;
        }
    });

    // 3. Odesl√°n√≠ jedin√©ho ≈ô√°dku dat do SheetDB
    const dataToSend = {
        data: [finalData] // Odes√≠l√°me pole obsahuj√≠c√≠ JEDEN objekt
    };
    
    // ... (zbytek fetch k√≥du pro odesl√°n√≠ dat, kde se zobrazuje podƒõkov√°n√≠) ...

    fetch(sheetDB_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(dataToSend)
    })
    .then(response => {
        // Kontrola, zda odesl√°n√≠ probƒõhlo √∫spƒõ≈°nƒõ
        if (response.ok) {
            document.querySelector('.jspsych-content').innerHTML = `
                <div style="text-align: center; max-width: 600px; margin: 40px auto;">
                    <h2>Dƒõkujeme za V√°≈° ƒças!</h2>
                    <p style="color: green; font-weight: bold;">‚úÖ Data byla √∫spƒõ≈°nƒõ ulo≈æena (ID: ${subjectID}).</p>
                    <p>M≈Ø≈æete zav≈ô√≠t toto okno.</p>
                </div>
            `;
            console.log('‚úÖ Data byla √∫spƒõ≈°nƒõ odesl√°na do Google Sheets (Wide Format).');
        } else {
            // ... (chybov√° hl√°≈°ka p≈ôi selh√°n√≠ serveru/SheetDB) ...
             document.querySelector('.jspsych-content').innerHTML = `
                <div style="text-align: center; max-width: 600px; margin: 40px auto; color: red;">
                    <h2>Dƒõkujeme ‚Äì Experiment dokonƒçen, ale s chybou ulo≈æen√≠!</h2>
                    <p>Do≈°lo k chybƒõ p≈ôi ukl√°d√°n√≠ dat (Chyba serveru). ID: ${subjectID}. Pros√≠m, kontaktujte experiment√°tora.</p>
                </div>
            `;
        }
    })
    .catch(error => {
        // ... (chybov√° hl√°≈°ka p≈ôi selh√°n√≠ s√≠tƒõ) ...
         document.querySelector('.jspsych-content').innerHTML = `
            <div style="text-align: center; max-width: 600px; margin: 40px auto; color: red;">
                <h2>Dƒõkujeme ‚Äì Experiment dokonƒçen, ale s chybou ulo≈æen√≠!</h2>
                <p>Do≈°lo k chybƒõ p≈ôi ukl√°d√°n√≠ dat (Chyba s√≠tƒõ). ID: ${subjectID}. Pros√≠m, kontaktujte experiment√°tora.</p>
            </div>
        `;
    });
}

/////////////////////////////////////////////////////////////////////////
// Funkce pro transformaci dat do "≈°irok√©ho" form√°tu pro SheetDB/Google Sheets
function processDataForWideFormat() {
    // 1. Z√≠sk√°n√≠ v≈°ech dat (jsPsych data)
    const allData = jsPsych.data.get().values();

    // 2. Extrahov√°n√≠ a uspo≈ô√°d√°n√≠ kl√≠ƒçov√Ωch promƒõnn√Ωch
    let wideData = {
        // Generujeme unik√°tn√≠ ID pro uchov√°n√≠ v JSONu, to bude i pro SheetDB
        // Pou≈æ√≠v√°me standardn√≠ jsPsych subject id
        // POZN.: Pou≈æijeme .values()[0].subject, pokud existuje.
        subjectID: jsPsych.data.get().values()[0] ? jsPsych.data.get().values()[0].subject : 'N/A'
    };

    // 3. Demografick√© √∫daje
    // ZMƒöNA ZDE: Pou≈æ√≠v√°me .find() na cel√©m poli dat m√≠sto ≈ôetƒõzen√≠ select/filter/values
    const demographyData = allData.find(d => d.task_name === 'demography');
    const demographyYearData = allData.find(d => d.task_name === 'demography_year');
    const demographyFormData = allData.find(d => d.task_name === 'demography_form');
    
    if (demographyData) {
        wideData.obor_studia = demographyData.study_field;
    }
    if (demographyYearData) {
        wideData.rocnik_studia = demographyYearData.study_year;
    }
    if (demographyFormData) {
        wideData.forma_studia = demographyFormData.study_form;
    }

    // 4. Data z √∫loh a dotazn√≠k≈Ø (tasks 1, 2, 3, 4, 5)
    const taskMappings = [
        { task: 'houseTask', prefix: 'uloha1' },
        { task: 'connectTask', prefix: 'uloha2' },
        { task: 'coloringTask', prefix: 'uloha3' },
        { task: 'eulerTask', prefix: 'uloha4' },
        { task: 'pathfindingTask', prefix: 'uloha5' } // 'pathfindingTask' je v k√≥du pro hamiltonTask
    ];

    taskMappings.forEach(mapping => {
        // Hled√°n√≠ dat pro √∫koly je nyn√≠ robustnƒõj≈°√≠: Hled√°me podle n√°zvu √∫kolu (task_name)
        let taskData = allData.find(d => d.task_name === mapping.task);

        if (taskData) {
            
            // Likertovy ≈°k√°ly (confidence, familiarity, strategy)
            wideData[`${mapping.prefix}_confidence`] = taskData.confidence;
            wideData[`${mapping.prefix}_familiarity`] = taskData.familiarity;
            wideData[`${mapping.prefix}_strategy_code`] = taskData.strategy;
            
            // Specifick√° data k √∫loh√°m
            if (mapping.task === 'houseTask') {
                wideData[`${mapping.prefix}_vertices_positions`] = taskData.vertices ? JSON.stringify(taskData.vertices.map(v => ({id: v.id, x: v.x, y: v.y}))) : '[]';
            } else if (mapping.task === 'connectTask') {
                wideData[`${mapping.prefix}_created_edges`] = taskData.created_edges ? JSON.stringify(taskData.created_edges) : '[]';
                wideData[`${mapping.prefix}_reset_count`] = taskData.reset_count; // Ulo≈æ√≠ reset pro √∫lohu 2
            } else if (mapping.task === 'coloringTask') {
                wideData[`${mapping.prefix}_vertex_colors`] = taskData.vertex_colors ? JSON.stringify(taskData.vertex_colors) : '{}';
                wideData[`${mapping.prefix}_min_colors_answer`] = taskData.chosen_answer;
            } else if (mapping.task === 'eulerTask') {
                wideData[`${mapping.prefix}_added_edges`] = taskData.blue_edges ? JSON.stringify(taskData.blue_edges) : '[]';
                wideData[`${mapping.prefix}_yellow_path_drawn`] = taskData.yellow_path_drawn; // task4_yellow (bool)
            } else if (mapping.task === 'pathfindingTask') {
                wideData[`${mapping.prefix}_final_path`] = taskData.final_path ? JSON.stringify(taskData.final_path) : '[]';
                wideData[`${mapping.prefix}_reset_count`] = taskData.reset_count; // Ulo≈æ√≠ reset pro √∫lohu 5
            }
            
            // P≈ôid√°me RT a ƒças startu/konce
            wideData[`${mapping.prefix}_rt`] = taskData.rt;
            wideData[`${mapping.prefix}_time_elapsed`] = taskData.time_elapsed; 
            
            // Vlo≈æ√≠me i text z textarea "Jin√Ω d≈Øvod" (pokud je pot≈ôeba)
            if (taskData.strategy_other_text) {
                wideData[`${mapping.prefix}_strategy_other_text`] = taskData.strategy_other_text;
            }
        }
    });

    // 5. Ulo≈æ√≠me i kompletn√≠ JSON data pro z√°lohu
    wideData.jspsych_raw_data = jsPsych.data.get().json();
    
    return wideData;
}

/////////////////////////////////////////////////////////////////////////
// Funkce pro odesl√°n√≠ dat do SheetDB
const SHEETDB_URL = 'https://sheetdb.io/api/v1/dknmz514rz0f5'; //

function sendDataToSheetDB() { //
    
    // Zpracov√°n√≠ dat prob√≠h√° uvnit≈ô funkce
    const dataToSend = processDataForWideFormat();
    const subjectID = dataToSend.subjectID; // Z√≠sk√°n√≠ ID pro chybov√© hl√°≈°ky
    
    // Zobraz√≠me "ulo≈æen√≠ dat" p≈ôed odesl√°n√≠m
    document.querySelector('.jspsych-content').innerHTML = `
        <div style="text-align: center; max-width: 600px; margin: 40px auto;">
            <h2>Ukl√°d√°m data...</h2>
            <p>Pros√≠m, ƒçekejte, dokud se data neulo≈æ√≠.</p>
        </div>
    `;
    
    // Vytvo≈ô√≠me payload pro SheetDB
    const payload = {
        data: [dataToSend] // Pou≈æ√≠v√°me dataToSend
    };

    fetch(SHEETDB_URL, {
        method: 'POST',
        headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
    })
    .then(response => {
        // Kontrola, zda odpovƒõƒè ze serveru naznaƒçuje √∫spƒõch
        if (response.ok || response.status === 201) {
            // √öspƒõ≈°n√© ulo≈æen√≠
            document.querySelector('.jspsych-content').innerHTML = `
                <div style="text-align: center; max-width: 600px; margin: 40px auto; color: green;">
                    <h2>Dƒõkujeme ‚Äì Experiment dokonƒçen!</h2>
                    <p>Va≈°e data byla √∫spƒõ≈°nƒõ ulo≈æena (ID: ${subjectID}).</p>
                    <p>M≈Ø≈æete zav≈ô√≠t toto okno.</p>
                </div>
            `;
            console.log('‚úÖ Data byla √∫spƒõ≈°nƒõ odesl√°na do Google Sheets (Wide Format).');
        } else {
            // Chyba na stranƒõ serveru/SheetDB
             document.querySelector('.jspsych-content').innerHTML = `
                <div style="text-align: center; max-width: 600px; margin: 40px auto; color: red;">
                    <h2>Dƒõkujeme ‚Äì Experiment dokonƒçen, ale s chybou ulo≈æen√≠!</h2>
                    <p>Do≈°lo k chybƒõ p≈ôi ukl√°d√°n√≠ dat (Chyba serveru). ID: ${subjectID}. Pros√≠m, kontaktujte experiment√°tora.</p>
                </div>
            `;
        }
    })
    .catch(error => {
        // Chyba s√≠tƒõ (nap≈ô. probl√©m s p≈ôipojen√≠m)
         document.querySelector('.jspsych-content').innerHTML = `
            <div style="text-align: center; max-width: 600px; margin: 40px auto; color: red;">
                <h2>Dƒõkujeme ‚Äì Experiment dokonƒçen, ale s chybou ulo≈æen√≠!</h2>
                <p>Do≈°lo k chybƒõ p≈ôi ukl√°d√°n√≠ dat (Chyba s√≠tƒõ). ID: ${subjectID}. Pros√≠m, kontaktujte experiment√°tora.</p>
            </div>
        `;
    });
}
	
jsPsych.run([informed_consent, demography_study_field, demography_study_year, demography_study_form, houseTask, connectTask, coloringTask, eulerTask, hamiltonTask], {
    // on_finish je standardn√≠ JSPsych handler, kter√Ω se spust√≠ po dokonƒçen√≠ experimentu
    on_finish: function() {
        // Vol√°me funkci BEZ jak√Ωchkoliv argument≈Ø
        sendDataToSheetDB(); 
    }
});

</script>
</body>
</html>
















